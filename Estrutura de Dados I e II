ğŸŒ¸ ANOTAÃ‡Ã•ES PROVA ğŸŒ¸

ğŸ¬ AplicaÃ§Ã£o de uma estrutura de dados:
    ğŸˆ Para realizar uma estrutura de dados Ã© necessÃ¡rio conhecer algumas operaÃ§Ãµes basicas:
        ğŸ’™ Como inserir um novo item;
        ğŸ’™ Como excluir um item jÃ¡ existente;
        ğŸ’™ Pesquisas e localizar determinado elemento;
        ğŸ’™ Classificar os itens em ordem, seja numerica, alfabetica ou outra.

ğŸ¬ Estrutura de dados Ã© uma modelagem abstrata dos objetos ou estruturas a serem manipulados e das operaÃ§Ãµes sobre eles.
    ğŸˆ Uma modelagem concreta Ã© relacionada aos Tipos Abstratos de Dados(TAD - Abstract Data Type)
        ğŸ’™ Podemos dizer que um tipo abstrato de dados Ã© um modelo que encapsula um modelo de dados e tambÃ©m um conjunto de procedimentos que atuam diretamente no tratamento desses dados encapsulados
        ğŸ’™ Um tipo de dados abstratos possui duas partes:
            ğŸ’› Dados armazenados
            ğŸ’› FunÃ§Ãµes que manipulam os dados
                ğŸ’¡ Os dados podem ser armazenados em variaveis vetores, ponteiros etc.
                ğŸ’¡ JÃ¡ as funÃ§Ãµes implementam procedimentos por meio de operaÃ§Ãµes, mÃ©todos, serviÃ§os. Ã‰ importante dizer que qualquer processamento realizado sÃ³ deve atuar sobre os dados encapsulados em um TAD,, alÃ©m disso os processamentos sÃ³ poderÃ£o acontecer intermÃ©dio dos procedimentos definidos no modelo do TAD.
                ğŸ’¡ Um exemplo de dado manipulado:   nome = nome.toUpperCase();
                ğŸ’¡ Outros exemplos: Pilha, filas, listas, Ã¡rvores (estruturas que armazenam os dados e relacionam cada dado com 2 ou mais dados), mapas/dicionÃ¡rios(estruturas comuns e relacionam chave com um valor: {idade:10,profissÃ£o:estudante})

        ğŸ’™ TAD Ã© um modelo matematico que visa representar um conjunto de operaÃ§Ãµes sobre um conjunto de valores. Um TAD Ã© normalmente representado atraves de uma especificaÃ§Ã£o algebrica que contÃ©m 3 partes: semantica, sintatica e restriÃ§Ãµes.
            ğŸ’› Semantica trata do comportamento de um tipo abstrato de dados;
            ğŸ’› Sintatico define a apresentaÃ§Ã£o de um tipo abstrato de dados;
            ğŸ’› RestriÃ§Ãµes como o proprio nome diz, sÃ£o responsaveis por estabelecer condiÃ§Ãµes para a aplicaÃ§Ã£o das operaÃ§Ãµes.

        ğŸ’™ Estruturas lineares: Elementos de dados sÃ£o organizados sequencialmente ou linearmente, onde os elementos sÃ£o anexados ao seu predecessor o ao sucessor. Podemos percorrer todos os elementos em uma unica execuÃ§Ã£o apenas. SÃ£o faceis de implementar porque a memoria do computador Ã© organizada de forma linear.

        ğŸ’™ Estrutura em que cada elemento pode ter um UNICO predecessor(menos o primeiro) e um unico sucessor (menos o ultimo).

        ğŸ’™ Quando se sabe o numero de elementos, algo que previamente voce sabe o tamanho, a quantidade.

            ğŸ’› Pilhas, filas, listas, arranjos, filas vinculadas, tabela hash sÃ£o exemplos de estruturas lineares.
            ğŸ’› Ex: O tanto de computadores numa sala, o tamanho de um vetor criado por voce.

        ğŸ’™ Estruturas nÃ£o lineares: Elementos de dados nÃ£o sÃ£o organizados sequencialmente ou linearmente. NÃ£o podemos percorrer todos os elementos em uma unica execuÃ§Ã£o apenas. NÃ£o sÃ£o faceis de implementar em comparaÃ§Ã£o com a estrutura de dados linear. Utiliza a memoria do computador de forma eficiente em comparaÃ§Ã£o a uma estrutura de dados linear.

        ğŸ’™ Estrutura que apesentam cada elemento podendo TER MAIS DE UM PREDECESSOR ou SUCESSOR.

        ğŸ’™ Quando nÃ£o se sabe o tamanho de elementos que voce tem, algo que nao sabemos a quantidade, algo que pode ser imprevisivel, pode ter mais de um predecessor ou sucessor. 

            ğŸ’› Arvores e grafos sÃ£o exemplos de estruturas nÃ£o-lineares.
                ğŸ’¡ Arvores: consiste em varios nÃ³s vinculados. Arvores sÃ£o hierarquicas, formando um relacionamento como o do pai e do filho. Essa estrutura Ã© formada de forma que haja uma conexao para cada relacionamento de nÃ³ pai-filho. Deve existir apenas um caminho entre a raiz e um nÃ³ na arvore.

                ğŸ’¡ Grafos: consistem em uma quantidade definida de vÃ©rtices e arestas. Os vÃ©rtices ou nÃ³s estao evnolvidos no armazenamento de dados e as arestas mostram a relaÃ§Ã£o dos vÃ©rtices. A diferenÃ§a entre um grafo e uma area Ã© que em um grafo nao existem regras especificas para a conexao de nÃ³s.

            ğŸ’› Ex: nÃ£o saber o tanto de alunos virÃ¡ pra uma aula, uma agenda telefonica, grafos e arvores.
            ğŸ’› Para busca de dados, a melhor opÃ§Ã£o de estrutura Ã© a nÃ£o-linear.
        
========================= AlocaÃ§Ã£o dinamica de memÃ³ria e etc SLIDE 2

ğŸ¬ Estruturas (Struct)

    ğŸˆ SÃ£o estruturas cujo seu conteudo contÃ©m muitas variaveis, seus elementos individuais podem ser de tipos diferentes. Uma struct Ã© uma coleÃ§Ã£o de variaveis referenciais por um nome. Atraves de uma estrutura Ã© possivel agrupar informaÃ§oes relacionadas.
    ğŸˆ Uma struct pode conter elementos inteiros, elementos float e elementos caracter. Ponteiros, matrizes e outras estruturas tambÃ©m podem ser elementos de uma estrutura.
    ğŸˆ Os elementos individuais de uma estrutura sÃ£o chamados de membros.
    ğŸˆ Um membro na estrutura pode ser acessado escrevendo-se: variavel.membro -> onde "variavel" refere-se ao nome de uma variavel estrutura e "membro" refere-se ao nome de um membro da estrutura.
    ğŸˆ O ponto (.) que separa o nome da variavel do nome do membro. Esse ponto Ã© um operador (operador ponto) que acessa o conteudo.

ğŸ¬ AlocaÃ§Ã£o de memÃ³ria

    ğŸˆ As informaÃ§Ãµes de um programa sempre estao armazenadas na memÃ³ria. Para que um programa possar armazenar iformaÃ§Ãµes em uma area de memÃ³ria Ã© necessario que tal area seja previamente alocada, ou seja, precisamos solicitar ao SO que reserve determinada area de memÃ³ria para o programa e que a proteja, para que outros programas nÃ£o utilizem essa regiÃ£o de memÃ³ria reservada ao programa em questÃ£o.

        ğŸ’™ Alocar uma area de memÃ³ria significa solicitar ao SO que reserve uma area para uso exclusivo de um determinado programa.

ğŸ¬ AlocaÃ§Ã£o estÃ¡tica x alocaÃ§Ã£o dinamica
    ğŸˆ EstÃ¡tica: os tipos de dados tem tamanho predefinido. O compilador vai alocar de forma automatica o espaÃ§o de memÃ³ria necessario. Sendo assim, dizemos que a alocaÃ§Ã£o estatica Ã© feito em tempo de compilaÃ§Ã£o. Esse tipo de alocaÃ§Ã£o tende a desperdiÃ§ar recursos, jÃ¡ que nem sempre Ã© possÃ­vel determinar previamente qual Ã© o espaÃ§o necessario p/ armazenar as informaÃ§Ãµes. Aqui Ã© mais comum o programador exagerar quando nao se conhece o espaÃ§o total necessario, entao a tendencia Ã© exagerar por Ã© melhor superdimensionar do que faltar espaÃ§o.

        ğŸ’™ Ou seja, a alocaÃ§Ã£o estÃ¡tica aloca regioes de memoria que serao utilizadas pelo programa, o problema Ã© que o tamanho Ã© calculado pelo compilador, nÃ£o podendo ser alterado durante a execuÃ§Ã£o de um programa. O programa pode pegar mais memÃ³ria do que o necessario, desnecessariamente.

    ğŸˆ Dinamica: Aqui podemos alocar espaÃ§os durante a execuÃ§Ã£o de um programa, ou seja, a alocaÃ§Ã£o dinamica Ã© feita em tempo de execuÃ§Ã£o. Isto Ã© bom pro programador, por permite que o espaÃ§o em memÃ³ria seja alocado apenas quando necessÃ¡rio. AlÃ©m disso, a alocaÃ§Ã£o dinamica permite aumentar ou atÃ© diminuir a quantidade de memÃ³ria alocada.

        ğŸ’™ O ideal seria alocar uma quantidade de memÃ³ria somente quando o programa necessitar e liberar para outros programa quando o mesmo nao estiver sendo mais utilizada. Aloca a memÃ³ria em tempo de execuÃ§Ã£o uma quantidade qualquer de memoria sem precisar conhecer seu tamanho previamente e libera essa area depois de utilizar. ğŸ’™ Permite o programa reservar uma area de memÃ³ria em tempo de execuÃ§Ã£o.
        ğŸ’™ A linguagem C disponibiliza varias funÃ§Ãµes para alocar, liberar e redimensionar areas de memÃ³ria. Essas funÃ§Ãµes estÃ£o na biblioteca malloc.h.
        ğŸ’™ A biblioteca que possui funÃ§Ãµes para alocar, liberar e redimensionar areas de memoria Ã© chamada de alloc.h.
        ğŸ’™ As funÃ§Ãµes da biblioteca malloc.h mais utilizadas sÃ£o malloc e free.

            ğŸ’› sizeof: A funÃ§Ã£o sizeof determina o numero de bytes para um determinado tipo de dados.
            ğŸ’› malloc(): o nome Ã© a abreviatura(memory allocation), solicita ao sistema alocar uma area de memÃ³ria, em tempo de execuÃ§Ã£o, do tamanho especificado. A funÃ§Ã£o malloc aloca um espaÃ§o de memÃ³ria e retorna um ponteiro do tipo void para o inicio do espaÃ§o de memÃ³ria alocado.
                ğŸ’¡ Aloca espaÃ§o para um bloco de bytes consecutivos na memoria RAM(random access memory) do computador e devolve o endereÃ§o desse bloco. O numero de bytes Ã© especificado no ARGUMENTO DA FUNÃ‡ÃƒO.
                ğŸ’¡ malloc(1) -> alocando 1 byte.
                ğŸ’¡ Muito utilizado na implementaÃ§Ã£o de estruturas de dados dinamicas, tipo listas encadeadas.
            ğŸ’› free(): ela libera uma area de memÃ³ria que jÃ¡ foi previamente alocada com o malloc().
                ğŸ’¡ As variaveis alocadas estaticamente dentro de uma funÃ§Ã£o, desaparecem assim que a execuÃ§Ã£o da funÃ§Ã£o termina.
                ğŸ’¡ As variaveis alocadas dinamicamente continuam a existir mesmo depois que a execuÃ§Ã£o da funÃ§Ã£o termina.

========================= RECURSIVIDADE

ğŸ¬ Chamamos de recursividade quando uma funÃ§Ã£o chama a si mesma.
    ğŸˆ Consiste em dividir um problema em um problema menor e mais simples
    ğŸˆ A recursividade Ã© mais lenta que a iteratividade.
    ğŸˆ 2 tipos de recursividade:
        ğŸ’™ Recursividade direta: a mesma funÃ§Ã£o tem uma chamada para ela mesma.
        ğŸ’™ Recursividade indireta: chama a primeira funÃ§Ã£o, nÃ£o necessariamente tem ligaÃ§Ã£o com a primeira.
    ğŸˆ Toda chamada recursiva cria uma variavel e o identificador dela.
    ğŸˆ Uma funÃ§Ã£o Ã© dita recursiva quando dentro do seu cÃ³digo existe uma chamada para si mesma.
    ğŸˆ Toda recursividade precisa de uma condiÃ§Ã£o de parada
    ğŸˆ Um algoritmo recursivo precisa:
        ğŸ’™ Deve conter pelo menos uma estrutura de condiÃ§Ã£o(if, if-else, switch-case)
        ğŸ’™ Deve invocar a si mesmo pelo menos uma vez ao ser executado.
    ğŸˆ Para todo algoritmo recursivo, existe um outro correspondente iterativo, que executa a mesma coisa(for, while...)
    ğŸˆ Nao pode transformar um algoritmo iterativo para recursivo, o contrario Ã© 'mais facil'
    ğŸˆ DiferenÃ§as de utilizaÃ§Ã£o das estruturas de repetiÃ§Ã£o:
        ğŸ’™ for = quando eu sei quantos tem, quando sei contar os numeros
        ğŸ’™ while = quando nao sei a quantidade das coisas e pode nao ter nenhum conteudo
        ğŸ’™ do while = quando nao sei a quantidade e deve ter pelo menos 1, ou seja, quando tiver pelo menos 1 unidade
    ğŸˆ Algoritmos recursivos possuem cÃ³digo mais claro, legivel e compacto
    ğŸˆ Toda recursividade Ã© composto por um caso base e pelas chamadas recursivas:
        ğŸ’™ Caso base: Ã© o caso mais simples. Ã‰ usada uma condiÃ§Ã£o em que se resolve o problema com facilidade.
        ğŸ’™ Chamadas recursivas: procuram simplificar o problema de tal forma que convergem para o caso base.
    ğŸˆ As desvantagens da recursividade:
        ğŸ’™ Consomem mais recursos, logo a apresentar um desempenho inferior aos iterativos, pois a iteratividade consome menos memÃ³ria e torna-se mais eficiente em termos de performance do que usar recursÃ£o.
        ğŸ’™ Consomem mais memoria e processamento do PC, memÃ³ria, devido ao uso intensivo da pilha
        ğŸ’™ SÃ£o mais dificeis de serem depurados, nao acessam a pilha com facilidade
    ğŸˆ O fatorial Ã© um exemplo classico de recursividade
	        n! = 1			se n = 0
	        n * (n-1)!		se n > 0
    ğŸˆ Basicamente os resultados no fatorial Ã© um empilhamento de numeros e depois desempilhando para gerar a multiplicaÃ§Ã£o
    ğŸˆ Uma funÃ§Ã£o nÃ£o recursiva Ã© a que apresenta uma estrutura de repetiÃ§Ã£o(for, while, do while)

ğŸ¬ DiferenÃ§as de i++ / ++i:

	ğŸˆ pÃ³s incremento i++ = Primeiro usa e depois executa, soma +1 e passa o valor(num contexto de funÃ§Ã£o), utiliza a variavel e depois soma. Primeiro apresenta o valor da variavel e depois soma + 1. Se eu rodar de novo, jÃ¡ mostrarÃ¡ o valor atualizado.

	ğŸˆ prÃ© incremento ++i = Executa todos os calculos e jÃ¡ printa com o resultado atualizado. Adiciona 1 unidade e jÃ¡ mostra o resultado. Primeiro incrementa e depois mostra.

========================= ğŸŒ¸ CONVERSÃƒO BYTES SIZEOF ARVORES
ğŸ¬ Arvores:
    ğŸˆ Tambem pode ser chamado de grafo, mas tem um ponto onde inicia toda a arvore.
	ğŸˆ NÃ£o tem retorno do filho para o pai, retorno da subarvore para a raiz, o filho nao pode ser o pai do proprio pai
	    ğŸ’™ Em grafo posso ir a varios elementos, arvores somente desce os niveis, ele nao volta para elementos anteriores.
	ğŸˆ Arvores sÃ£o estrutura de dados hierarquicas.
	ğŸˆ Arvores sao formadas por um conjunto de elementos, os quais chamamos de nodos(ou vÃ©rtices) conectados de forma especifica por um conjunto de arestas.
	ğŸˆ Nivel 0 Ã© a raiz da arvore, e estÃ¡ no topo da hierarquia.
	ğŸˆ Outros nodos estÃ£o conectados ao nodo raiz e aos demais nodos. Ou seja, sÃ£o interligados.
	ğŸˆ As conexÃµes entre os nodos de uma arvore seguem uma nomenclatura genealogica. Um nodo em um dado nivel esta conectado a seus filhos(no nivel abaixo) e a seu pai(no nivel acima). A raiz da arvore possui filhos, mas nao possui pai, Ã© o nivel 0.
	ğŸˆ A arvore Ã© um relacionamento logico, tem relaÃ§Ã£o os elementos uns com os outros
	ğŸˆ HÃ¡ uma subordinaÃ§Ã£o, hierarquia.
	ğŸˆ Onde: um subconjunto dos componentes Ã© subordinado a outro.

    ğŸ’¡ Utilizamos a arvore em:
	    ğŸˆ Pasta do explorer.
	    ğŸˆ Historico da web: elementos hierarquicos, o ultimo elemento consultado Ã© o topo da arvore.
	    ğŸˆ Rotas de um trajeto: varios caminhos, mas sempre percorre 1 caminho.
	    ğŸˆ Chaves de jogos de times de futebol:
		    ğŸ’™ Pode-se dizer que uma estrutura hierarquica testa as condiÃ§Ãµes, se hÃ¡ algo de maior hierarquia, nao faz sentido testar as outras condiÃ§Ãµes com baixa prioridade.
	
	ğŸˆ OrdenaÃ§Ã£o de valores: Em arvore binaria hÃ¡ somente 1 elemento distinto (raiz), com 2 elementos para duas estruturas diferentes, ou nenhum caminho. Basicamente, um pai com 2 filhos mesmo.

	ğŸˆ Diagrama de inclusÃ£o: Pode-se dizer que Ã© como o "Universal" em teoria dos conjuntos.
    ğŸˆ Pode-se dizer que a raiz Ã© como o conjunto universal, ela engloba todos os nÃ³s, os nÃ³s das sub-arvore sÃ£o os conjuntos restantes e a cada conjunto(nÃ³) hÃ¡ outros nÃ³s dentro deste conjunto.
    ğŸˆ O diagrama de venn Ã© algo que pode representar e o Conjunto Universo Ã© a definiÃ§Ã£o boa pra isso (no caso aqui, o universo Ã© o pai) e os subconjuntos(que no caso aqui sÃ£o os filhos)

    ğŸ’¡ Arvores - Terminologias(resumo delas)
        ğŸˆ Raiz: nÃ³ de origem da arvore
        ğŸˆ Folhas: nÃ³s que nao tem filho
        ğŸˆ Grau de um nÃ³: numero de filhos de cada nÃ³(numero de subarvores de um nÃ³)
        ğŸˆ Nivel de um nÃ³: Ã© o numero de linhas que ligam o nÃ³ a raiz, Ã© a distancia do nÃ³ atÃ© a raiz.
        ğŸˆ Altura: Ã© o nivel mais alto da arvore
        ğŸˆ Floresta: conjunto de arvores
        ğŸˆ Galhos: nÃ³s que nao sao raiz e nem folhas, nÃ³s internos
        ğŸˆ Aresta de uma arvore: linha que liga 2 nÃ³s da arvore
        ğŸˆ Caminho: caminho entre 2 nÃ³s de uma arvore, percorrendo as arestas que ligam os nÃ³s.
        ğŸˆ Isomorfas: Arvores que podem se tornar simultaneas nas subarvores, ou seja, podem fazer uma "inversÃ£o" nas subarvores. Preserva a estrutura geral da arvore, sÃ³ trocando seus valores.

        ğŸˆ Calcular percursos:
            ğŸ“Œ PrÃ© ordem: ComeÃ§a da raiz e anda pelos nÃ³s da esquerda, passando para a direita, envelopa todos os nÃ³s da esquerda para a direita. USA a raiz como primeiro elemento.
                ğŸ’™ A aÃ§Ã£o no nÃ³ Ã© feita pela esquerda, cada passada no nÃ³ indicarÃ¡ um "print", uma aÃ§Ã£o.
            ğŸ“Œ Em ordem: ComeÃ§a pelos filhos da esquerda, depois pra raiz e depois pros filhos da esquerda, a aÃ§Ã£o Ã© feita por baixo. NÃ£o usa a raiz como primeiro elemento.
           ğŸ“Œ PÃ³s-ordem: Imprime sempre que passar PELA DIREITA do nÃ³. NÃ£o usa a raiz como primeiro elemento.

                 4     A ordem de print dessa arvore Ã©:
             /      \           PrÃ©-ordem: 4, 1, 3, 2, 6, 5, 7
            1        6          Em ordem: 1, 2, 3, 4, 5, 6, 7
             \      / \         PÃ³s-ordem: 2, 3, 1, 5, 7, 6, 4
              3    5   7
             /
            2

    ğŸ’¡ Arvores - DefiniÃ§Ã£o
	    ğŸˆ Quando eu tenho uma raiz qualquer nÃ³ Ã© um subconjunto da minha raiz. A partir da raiz, os demais abaixo sao sub arvores.
	    ğŸˆ Toda arvore TEM raiz, se nao tiver nao Ã© uma arvore. Quando tem mais de 1 nÃ³, hÃ¡ subarvores.
        ğŸˆ Se o numero de nÃ³s for igual a zero: arvore vazia.
        
    ğŸ’¡ Arvores - Grau de um nÃ³, grau significa o numero de filhos de cada nÃ³.
	    ğŸˆ Grau de saida
        ğŸˆ Grau 0:  0 filhos -> chama-se de nÃ³ folha.
	    ğŸˆ Grau 1:  1 filho
	    ğŸˆ Grau 2:  2 filhos
	    ğŸˆ Grau 3:  3 filhos -> precisa de no minimo 3 filhos para ser representado. 
            ğŸ“Œ Esse grau 3 Ã© para arvores gerais, nao se aplica a arvore binaria.

    ğŸ’¡ Arvores - nÃ³
        ğŸˆ Cada nÃ³ pode ter no maximo 2 filhos, pode ter 0 1 ou 2 filhos.
	    ğŸˆ NÃ³ interno, nÃ³ de derivaÃ§Ã£o: sÃ£o aqueles que estÃ£o no caminho entre a raiz da arvore e os nÃ³s folha.
	    ğŸˆ NÃ³ com grau maior do que zero: tem pelo menos 1 filho
	    ğŸˆ NÃ³ folha(nÃ³ terminal ou externo), nÃ³ com grau igual a zero. Praticamente o fim da arvore, nÃ³s sem filhos.

    ğŸ’¡ Arvore - nÃ­vel
        ğŸˆ NÃ­vel: Cima pra baixo, da raiz para as folhas
	    ğŸˆ Nivel = O nivel de um nÃ³ refere-se a sua posiÃ§Ã£o na arvore, a partir da raiz. 
        ğŸˆ Representa a profundidade de um nÃ³ na arvore, medido a partir da raiz.
        ğŸˆ Raiz Ã© nivel 1. Os nÃ³s filhos estÃ£o no nivel 2, os filhos do nivel 2 estÃ£o no nivel 3.
	        ğŸˆ Primeiro nivel = raiz
	        ğŸˆ Segundo nivel = filhos do nivel 1
	        ğŸˆ Terceiro nivel = filhos do nivel 2
	        ğŸˆ Quarto nivel = filhos do nivel 3
        ğŸˆ A cada nivel, a quantidade de nÃ³s existente na arvore Ã© multiplicado x2, por exemplo:
            ğŸ’™ Nivel 1 = 1 nÃ³
            ğŸ’™ Nivel 2 = 2 nÃ³s
            ğŸ’™ Nivel 3 = 4 nÃ³s (2 x 2, nivel 2 multiplica x 2)
            ğŸ’™ Nivel 4 = 8 nÃ³s (4 x 2, nivel 3 multiplica x 2)

    ğŸ’¡ Arvore - Altura de um nÃ³: numero de ligaÃ§Ãµes entre o nÃ³ e o nÃ³ folha de maior nivel, acrescido de uma unidade
        ğŸˆ Altura: Baixo pra cima, das folhas para a raiz
	    ğŸˆ Altura de nÃ³ folha Ã© 1
	    ğŸˆ A altura comeÃ§a nas folhas(subfilhos)
	    ğŸˆ A menor altura Ã© o elemento mais profundo da arvore, vulgo os ultimos elementos
        ğŸˆ Caminho Ã© a sequencia de nÃ³s que eu percorro na linha da arvore, pode medir pelas arestas ou pelos nÃ³s.
        ğŸˆ Altura Ã© o comprimento do caminho entre a raiz e a folha mais profunda, numero de ligaÃ§Ãµes entre os nÃ³s do caminho.
        ğŸˆ Em uma arvore binaria, a altura Ã© a maior distancia que existe entre o nÃ³ raiz e o nÃ³ folha

    ğŸ’¡ Arvore ordenada: Uma arvore Ã© ordenada quando os filhos estÃ£o ordenados, da esquerda pra direita.
        ğŸˆ O valor de cada nÃ³ na esquerda Ã© MENOR que o valor da raiz.
        ğŸˆ O valor de cada nÃ³ na direita Ã© MAIOR que o valor da raiz.
        Ex:
              B     ->  B Ã© a raiz.
             / \    ->  A vem primeiro que B.
            A   C   ->  C vem depois de B.

    ğŸ’¡ Arvores AVL: 
        ğŸˆ Toda AVL Ã© uma arvore binaria
        ğŸˆ Sempre trabalhar com arvore cheia ou completa.
        ğŸˆ Cheia: todos os nÃ³s estao completos, os filhos tem filhos, somente no ultimo nÃ­vel tem nÃ³s vazios.
        ğŸˆ Completa: Somente no ultimo ou penultimo nÃ³ estao vazios.
        ğŸˆ Arvore cheia Ã© uma arvore ja balanceada.
        ğŸˆ Altura funciona como a contagem de nÃ³s, iniciando-se em 0 de baixo pra cima.
        ğŸˆ O calculo de altura Ã© feita SEMPRE em modulo. | |, o resultado sempre serÃ¡ positivo.
           ğŸ’™ | Altura da esquerda - altura da direita |, TUDO EM MÃ“DULO.
           ğŸ’™ Sinais diferentes = -
           ğŸ’™ Sinais iguais = +
           ğŸ’™ 0 - 1 = -1
           ğŸ’™ Para fazer esse calculo precisa contar quantos nÃ³s o valor que voce parou tem, por exemplo:
                O meu nÃ³ tem 1 filho pra esquerda e 0 pra direita:
                    1 - 0 = 1
                O meu nÃ³ tem 0 filho na esquerda e 1 na direita:
                    0 - 1 = -1
                O meu nÃ³ tem 0 filho na esquerda e 2 na direita:
                    0 - 2 = -2
                
                4       -> 0 nÃ³ esquerda, 2 nÃ³ direita: 0 - 2 = -2
                 \   
                  6     -> 0 nÃ³ esquerda, 1 nÃ³ direita: 0 - 1 = -1
                   \ 
                    7   -> nivel 0

                27       -> 3 nÃ³ esquerda, 1 nÃ³ direita: 3 - 1 = 2
               /  \   
              15   49     -> 49 = nivel 0 ///// 
             /            -> 15 = 2 nÃ³ esquerda, 0 nÃ³ direita: 2 - 0 = 2
             
            10   -> 1 nÃ³ esquerda, 0 nÃ³ direita: 1 - 0 = 1  
           /
          8     -> nivel 0


        ğŸˆ NÃ³ sem filhos pode-se pensado como 0, mas o calculo ainda precisa ser feito pelo PC, precisamos implementar a operaÃ§Ã£o em cÃ³digo.
        ğŸˆ A montagem da arvore Ã© sempre pela ordem de inserÃ§Ã£o, a raiz Ã© o primeiro elemento que aparece (11,35,9 -> a raiz Ã© 11).
        ğŸˆ O conceito balancear uma arvore Ã© para otimizar a busca de algum elemento, pois consequentemente haverÃ¡ poucas comparaÃ§Ãµes.
        ğŸˆ Altura Ã© de baixo para cima.
        ğŸˆ Os elementos organizados um atras do outro Ã© um vetor, e nao uma arvore.
        ğŸˆ Calculo de balanceamento:
		ğŸˆ Se o resultado for 0 ou 1 Ã© porque ta balanceado, se estiver acima de 1 (exatos 2, ou mais que 2) Ã© porque estÃ¡ desbalanceado. 
            ğŸ’™ LEMBRAR DO NÃ“ QUE NÃƒO TEM FILHO = 0 (-1 Ã© o nÃ³ "oculto", vem antes do nÃ³ 0).

        ğŸˆ O algoritmo de busca em arvores binarias de pesquisa podem ser divididos em 3 casos:
            ğŸ’™ O valor procurado estÃ¡ na raiz. Nisso o programa acaba e retornamos o valor da raiz como resultado.
            ğŸ’™ O valor procurado Ã© menor que numero da raiz. Aqui procurando pelo valor somente na subarvore da esquerda, pois Ã© onde os menores valores em relaÃ§Ã£o a raiz estao.
            ğŸ’™ O valor procurando Ã© maior que o numero da raiz. Aqui temos que procurar nas subarvores da direita, pois lÃ¡ estao os valores que sao maiores que o valor da raiz.

ğŸ¬ ConversÃ£o bytes e bits
    
    ğŸ’¡ğŸ’¡ 8 bits = 1 byte ğŸ’¡ğŸ’¡

    ğŸ’¡ bits para byte = dividir por 8
    ğŸ’¡ byte para bits = multiplicar por 8 
        ğŸˆ BIT (b) > BYTE (B) = divisÃ£o
        ğŸˆ BYTE (B) > BIT (b) multiplicaÃ§Ã£o
            ğŸ“Œ b minusculo = bits
            ğŸ“Œ B maiusculo = bytes

    ğŸˆ 10 Mbps = 10 megabits por segundo
    ğŸˆ 10 Mbps / 8 = 1,25 MB (1,25 megabytes)
        
    ğŸˆ 800 bits = 100 bytes (foi dividido: 800 / 8 = 100)
    
    ğŸˆ K = quilo = mil BYTES            (1.000)
    ğŸˆ M = mega = milhÃµes de BYTES      (1.000.000)
    ğŸˆ G = giga = bilhÃµes de BYTES      (1.000.000.000)
    ğŸˆ T = tera = trilhÃµes de BYTES     (1.000.000.000.000)

ğŸ¬ Operador sizeof
    ğŸˆ A funÃ§Ã£o sizeof determina o numero de bytes para um determinado tipo de dados.
    ğŸˆ Retorna o tamanho de um dado.
    ğŸˆ Sizeof eu pego o tamanho da variavel de forma dinamica.
